### 1.同步编程

所谓同步编程，就是计算机一行一行按顺序依次执行代码，当前代码任务耗时执行会阻塞后续代码的执行。 

同步编程，即是一种典型的请求-响应模型，当请求调用一个函数或方法后，需等待其响应返回，然后执行后续代码。

一般情况下，同步编程，代码按序依次执行，能很好的保证程序的执行，但是在某些场景下，比如读取文件内容，或请求服务器接口数据，需要根据返回的数据内容执行后续操作，读取文件和请求接口直到数据返回这一过程是需要时间的，网络越差，耗费时间越长，如果按照同步编程方式实现，在等待数据返回这段时间，JavaScript是不能处理其他任务的，此时页面的交互，滚动等任何操作也都会被阻塞，这显然是及其不友好，不可接受的，而这正是需要异步编程大显身手的场景，如下图，耗时任务A会阻塞任务B的执行，等到任务A执行完才能继续执行B：

![](https://pic1.zhimg.com/80/v2-3f4f2aa084760b9b72d0cb5c055bad10_720w.png '同步函数执行')

当使用异步编程时，在等待当前任务的响应返回之前，可以继续执行后续代码，即当前执行任务不会阻塞后续执行。

### 2.异步编程

异步编程，不同于同步编程的请求-响应模式，其是一种事件驱动编程，请求调用函数或方法后，无需立即等待响应，可以继续执行其他任务，而之前任务响应返回后可以通过状态、通知和回调来通知调用者。

### 3.多线程

前面说明了异步编程能很好的解决同步编程阻塞的问题，那么实现异步的方式有哪些呢？通常实现异步方式是多线程，如C#, 即同时开启多个线程，不同操作能并行执行，如下图，耗时任务A执行的同时，在线程二中任务B也可以执行：

![](https://pic1.zhimg.com/v2-c4b4563a0a6c4f98c74799f5802d4804_r.jpg '多线程')

### 4.并行与并发

前文提到多线程的任务可以并行执行，而JavaScript单线程异步编程可以实现多任务并发执行，这里有必要说明一下并行与并发的区别。

并行：指同一时刻内多任务同时进行
并发：指在同一时间段内，多任务同时进行着，但是某一时刻，只有某一任务执行

通常所说的并发连接数，是指浏览器向服务器发起请求，建立TCP连接，每秒钟服务器建立的总连接数，而假如服务器10ms能处理一个请求，那么并发连接数就是100。

### 5.JavaScript异步机制

首先来看一个例子：
```
for(var i=0;i<5;i++){
   setTimeout(()=>{
      console.log(i)
   },0)
}
// 5,5,5,5,5
```
应该明白最后输出的全是5：
1. i在此处是for循环所在上下文环境的变量，有且只有一个；
2. 循环结束时i==5
3. JavaScript单线程事件处理器在线程空闲前不会执行下一事件

如上面第三点所述，如果真正理解以上例子中的setTimeout()，及Javascript异步机制需要理解JavaScript的事件循环和并发模型

### 6.并模型发(Concurrency model)

目前，我们已经知道，JavaScript执行异步任务时，不需要等待响应返回，可以继续执行其他任务，而在响应返回时，会得到通知，执行回调，或事件处理
程序。那么这一切具体是如何完成的，又是以什么规则或顺序运作呢？接下来我们需要解答这个问题。

#### 注：回调和事件处理程序本质上并无区别，只是在不同情况下，不同的叫法
前文已经提到，JavaScript异步编程使得多个任务可以并发执行，而实现这一功能的基础是JavaScript拥有一个基于事件循环的并发模型

### 7.堆栈与队列

介绍JavaScript并发模型之前，先简单介绍堆栈和队列的区别：

堆（heap）：内存中某一未被阻止的区域，通常存储对象（引用类型）；
![](https://img2018.cnblogs.com/blog/1028513/201902/1028513-20190212172615929-1326231962.jpg '堆')

栈（stack）：后进先出的顺序存储数据结构，通常存储函数参数和基本类型值变量（按值访问）；
![](https://img2018.cnblogs.com/blog/1028513/201902/1028513-20190212171914206-1645974025.jpg '栈')

队列（queue）：先进先出顺序存储数据结构，
#### 注意："与栈的区别：栈的存入取出都在顶部一个出入口，而队列分两个，一个出口，一个入口"。
举个栗子：排队取餐
![](https://img2018.cnblogs.com/blog/1028513/201902/1028513-20190212172311256-626494157.jpg '队列')

### 8.事件循环（Event Loop）

JavaScript引擎负责解析，执行JavaScript代码，但它并不能单独运行，通常都得有一个宿主环境，一般如浏览器或Node服务器，前文说到的单线程是指在这些宿主环境创建单一线程，提供一种机制，调用JavaScript引擎完成多个JavaScript代码块的调度，执行（是的，JavaScript代码都是按块执行的），这种机制就称为事件循环（Event Loop）。

JavaScript执行环境中存在的两个结构需要了解：

消息队列(message queue)，也叫任务队列（task queue）：存储待处理消息及对应的回调函数或事件处理程序；

执行栈(execution context stack)，也可以叫执行上下文栈：JavaScript执行栈，顾名思义，是由执行上下文组成，当函数调用时，创建并插入一个执行上下文，通常称为执行栈帧（frame），存储着函数参数和局部变量，当该函数执行结束时，弹出该执行栈帧；
#### 注：关于全局代码，由于所有的代码都是在全局上下文执行，所以执行栈顶总是全局上下文就很容易理解，直到所有代码执行完毕，全局上下文退出执行栈，栈清空了；也即是全局上下文是第一个入栈，最后一个出栈。

### 9.任务

分析事件循环流程前，先阐述两个概念，有助于理解事件循环：同步任务和异步任务。
      

任务很好理解，JavaScript代码执行就是在完成任务，所谓任务就是一个函数或一个代码块，通常以功能或目的划分，比如完成一次加法计算，完成一次ajax请求；很自然的就分为同步任务和异步任务。同步任务是连续的，阻塞的；而异步任务则是不连续，非阻塞的，包含异步事件及其回调，当我们谈及执行异步任务时，通常指执行其回调函数。


### 9.事件循环流程

关于事件循环流程分解如下：

1. 宿主环境为JavaScript创建线程时，会创建堆(heap)和栈(stack)，堆内存储JavaScript对象，栈内存储执行上下文；

2. 栈内执行上下文的同步任务按序执行，执行完即退栈，而当异步任务执行时，该异步任务进入等待状态（不入栈），同时通知线程：当触发该事件时（或该异步操作响应返回时），需向消息队列插入一个事件消息；

3. 当事件触发或响应返回时，线程向消息队列插入该事件消息（包含事件及回调）；

4. 当栈内同步任务执行完毕后，线程从消息队列取出一个事件消息，其对应异步任务（函数）入栈，执行回调函数，如果未绑定回调，这个消息会被丢弃，执行完任务后退栈；

5. 当线程空闲（即执行栈清空）时继续拉取消息队列下一轮消息（next tick，事件循环流转一次称为一次tick）。

使用代码可以描述如下：
```
var eventLoop = [];
    var event;
    var i = eventLoop.length - 1; // 后进先出

    while(eventLoop[i]) {
        event = eventLoop[i--]; 
        if (event) { // 事件回调存在
            event();
        }
        // 否则事件消息被丢弃
    }
```
这里注意的一点是等待下一个事件消息的过程是同步的。

并发模型与事件循环
```
var ele = document.querySelector('body');

    function clickCb(event) {
        console.log('clicked');
    }
    function bindEvent(callback) {
        ele.addEventListener('click', callback);
    }   

    bindEvent(clickCb);
```

针对如上代码我们可以构建如下并发模型：
![](https://pic4.zhimg.com/80/v2-79e06e26a020c37e499f96375075b06f_720w.png '并发模型')
